'use client';

import React, { useState, useEffect } from 'react';
import GameSelection from '@/components/GameSelection';
import ChatScreen from '@/components/ChatScreen';
import TranslationDebugger from '@/components/TranslationDebugger';
import { Game, ChatMessage, ResearchStage } from '@/types/game';
import { fetchGames, GameFilters } from '@/features/games/api';
import { errorHandler, AppError } from '@/lib/error-handler';
import { askGameQuestionWithContextTracking } from '@/lib/gemini';
import { 
  usePageView, 
  useGameSelectionTracking, 
  useQuestionTracking, 
  useEngagementTracking 
} from '@/lib/analytics';

export default function Home() {
  const [currentPage, setCurrentPage] = useState<'selection' | 'chat' | 'debug'>('selection');
  const [selectedGame, setSelectedGame] = useState<Game | null>(null);
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [researchStage, setResearchStage] = useState<ResearchStage>('analyzing');
  const [games, setGames] = useState<Game[]>([]);
  const [filters, setFilters] = useState<GameFilters>({});
  const [loadingError, setLoadingError] = useState<string | null>(null);
  const [searchTerm, setSearchTerm] = useState<string>('');
  const [sessionId, setSessionId] = useState<string>('');

  // Analytics ÌõÖ Ï¥àÍ∏∞Ìôî
  const { trackGameSelection, trackGameSearch } = useGameSelectionTracking();
  const { trackQuestionSubmitted, trackResearchUsed, trackAIResponse } = useQuestionTracking();
  const { trackSessionStart, trackSessionEnd, trackUserExit, trackError } = useEngagementTracking();

  // ÌéòÏù¥ÏßÄÎ∑∞ Ï∂îÏ†Å
  usePageView(currentPage === 'selection' ? '/' : currentPage === 'chat' ? '/chat' : '/debug');

  useEffect(() => {
    const loadGames = async () => {
      try {
        setLoadingError(null);
        const searchFilters = { ...filters, searchTerm };
        const fetchedGames = await fetchGames(searchFilters);
        setGames(fetchedGames);
      } catch (error) {
        const appError = errorHandler.handle(error, {
          context: 'loading games',
          action: 'fetchGames',
          filters: { ...filters, searchTerm }
        });
        setLoadingError(appError.message);
      }
    };

    loadGames();
  }, [filters, searchTerm]);

  const handleGameSelect = (game: Game) => {
    console.log('üéØ Í≤åÏûÑ ÏÑ†ÌÉù:', game.title);

    // Ï§ëÎ≥µ ÌÅ¥Î¶≠ Î∞©ÏßÄ - Îçî Ï†ïÌôïÌïú Ï°∞Í±¥ ÏÑ§Ï†ï
    if (selectedGame?.id === game.id) {
      console.log('‚ö†Ô∏è Ïù¥ÎØ∏ ÏÑ†ÌÉùÎêú Í≤åÏûÑ');
      return;
    }

    // ÏÉàÎ°úÏö¥ ÏÑ∏ÏÖò ID ÏÉùÏÑ± (ÎåÄÌôî Îß•ÎùΩ Ï∂îÏ†ÅÏö©)
    const newSessionId = `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    setSessionId(newSessionId);
    console.log('üÜî ÏÉà ÏÑ∏ÏÖò ID ÏÉùÏÑ±:', newSessionId);

    // Analytics: Í≤åÏûÑ ÏÑ†ÌÉù Ï∂îÏ†Å
    trackGameSelection(game.title, game.id.toString(), 'click');
    trackSessionStart(newSessionId);

    // ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏Î•º ÎèôÍ∏∞Ï†ÅÏúºÎ°ú Ï≤òÎ¶¨
    setSelectedGame(game);

    // ÌôòÏòÅ Î©îÏãúÏßÄ ÏÉùÏÑ±
    const welcomeMessage: ChatMessage = {
      role: 'assistant',
      content: `ÏïàÎÖïÌïòÏÑ∏Ïöî! Ï†ÄÎäî **${game.title}**Ïùò Î£∞ ÎßàÏä§ÌÑ∞ÏûÖÎãàÎã§. üé≤üìñ

Ïù¥ Í≤åÏûÑÏóê ÎåÄÌïú Ïñ¥Îñ§ Î£∞Ïù¥ÎÇò ÏßàÎ¨∏Ïù¥Îì† Î¨ºÏñ¥Î≥¥ÏÑ∏Ïöî! 

‚Ä¢ Í∏∞Î≥∏ Í≤åÏûÑ Î∞©Î≤ï
‚Ä¢ ÌäπÏàò Ïπ¥ÎìúÎÇò Îä•Î†• Ìö®Í≥º  
‚Ä¢ Ïï†Îß§Ìïú ÏÉÅÌô© Ìï¥ÏÑù
‚Ä¢ Í≤åÏûÑ ÏßÑÌñâ Ï§ë Í∂ÅÍ∏àÌïú Ï†ê

Î¨¥ÏóáÏù¥Îì† ÎèÑÏôÄÎìúÎ¶¥Í≤åÏöî! Ïñ¥Îñ§ Í≤ÉÏù¥ Í∂ÅÍ∏àÌïòÏã†Í∞ÄÏöî? ü§î`
    };

    setMessages([welcomeMessage]);
    setCurrentPage('chat');
    
    console.log('üìÑ ÌéòÏù¥ÏßÄ Ï†ÑÌôò ÏôÑÎ£å');
  };

  const handleBackToSelection = () => {
    setCurrentPage('selection');
    setSelectedGame(null);
    setMessages([]);
    setResearchStage('analyzing');
  };

  const handleSendMessage = async (
    content: string, 
    callbacks?: {
      onResearchStart?: () => void;
      onResearchProgress?: (stage: ResearchStage) => void;
      onComplete?: () => void;
    }
  ) => {
    if (!selectedGame) return;

    const userMessage: ChatMessage = {
      role: 'user',
      content
    };

    setMessages(prev => [...prev, userMessage]);
    setIsLoading(true);
    setResearchStage('analyzing');

    try {
      // Analytics: ÏßàÎ¨∏ Ï†ÑÏÜ° Ï∂îÏ†Å
      trackQuestionSubmitted(selectedGame.title, content.length, false);
      
      const startTime = Date.now();

      // Î¶¨ÏÑúÏπò ÏãúÏûë ÏΩúÎ∞± Ìò∏Ï∂ú
      if (callbacks?.onResearchStart) {
        callbacks.onResearchStart();
      }

      // ÌîÑÎ°úÍ∑∏Î†àÏä§ Îã®Í≥ÑÎ≥Ñ ÏΩúÎ∞± Ìò∏Ï∂úÏùÑ ÏúÑÌïú ÏãúÎÆ¨Î†àÏù¥ÏÖò
      const simulateProgress = async () => {
        const stages: ResearchStage[] = [
          'analyzing', 
          'searching', 
          'processing', 
          'summarizing', 
          'generating_logic',
          'generating_text', 
          'generating_review'
        ];
        
        for (const stage of stages) {
          if (callbacks?.onResearchProgress) {
            callbacks.onResearchProgress(stage);
          }
          // Í∞Å Îã®Í≥ÑÎ≥ÑÎ°ú ÏïΩÍ∞ÑÏùò ÏßÄÏó∞ÏùÑ Ï£ºÏñ¥ Ïã§Ï†ú ÏßÑÌñâ ÏÉÅÌô©ÏùÑ ÏãúÎÆ¨Î†àÏù¥ÏÖò
          await new Promise(resolve => setTimeout(resolve, 500));
        }
      };

      // ÌîÑÎ°úÍ∑∏Î†àÏä§ ÏãúÎÆ¨Î†àÏù¥ÏÖòÍ≥º AI ÏùëÎãµÏùÑ Î≥ëÎ†¨Î°ú Ïã§Ìñâ (Îß•ÎùΩ Ï∂îÏ†Å ÌôúÏÑ±Ìôî)
      const [response] = await Promise.all([
        askGameQuestionWithContextTracking(
          selectedGame.title, 
          content, 
          sessionId,
          callbacks?.onResearchStart
        ),
        simulateProgress()
      ]);

      const responseTime = Date.now() - startTime;

      // Analytics: Î¶¨ÏÑúÏπò ÏÇ¨Ïö© Î∞è AI ÏùëÎãµ Ï∂îÏ†Å
      if (typeof response !== 'string' && response.researchUsed) {
        trackResearchUsed(selectedGame.title, response.complexity?.score || 0, responseTime);
      }
      trackAIResponse(responseTime, true);

      const aiMessage: ChatMessage = {
        role: 'assistant',
        content: typeof response === 'string' ? response : response.answer,
        // API ÏùëÎãµÏóêÏÑú Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Ï∂îÏ∂úÌïòÏó¨ Ìè¨Ìï®
        researchUsed: typeof response !== 'string' ? response.researchUsed : false,
        sources: typeof response !== 'string' ? response.sources : undefined,
        fromCache: typeof response !== 'string' ? response.fromCache : undefined,
        complexity: typeof response !== 'string' ? response.complexity : undefined,
        analysisV2: typeof response !== 'string' ? response.analysisV2 : undefined
      };

      setMessages(prev => [...prev, aiMessage]);
    } catch (error) {
      const appError = errorHandler.handle(error, {
        context: 'asking game question',
        action: 'askGameQuestionWithContextTracking',
        gameName: selectedGame.title,
        question: content
      });

      const errorMessage: ChatMessage = {
        role: 'assistant',
        content: `Ï£ÑÏÜ°Ìï©ÎãàÎã§. Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: ${appError.message}`
      };

      setMessages(prev => [...prev, errorMessage]);
    } finally {
      setIsLoading(false);
      setResearchStage('completed');
      
      // ÏôÑÎ£å ÏΩúÎ∞± Ìò∏Ï∂ú
      if (callbacks?.onComplete) {
        callbacks.onComplete();
      }
    }
  };

  if (currentPage === 'debug') {
    return (
      <div className="min-h-screen bg-game-table-dark">
        <div className="container mx-auto px-4 py-8">
          <button
            onClick={() => setCurrentPage('selection')}
            className="btn-game-secondary mb-6"
          >
            ‚Üê Î©îÏù∏ÏúºÎ°ú ÎèåÏïÑÍ∞ÄÍ∏∞
          </button>
          <TranslationDebugger onGoBack={() => setCurrentPage('selection')} />
        </div>
      </div>
    );
  }

  if (currentPage === 'chat' && selectedGame) {
    return (
      <ChatScreen
        game={selectedGame}
        messages={messages}
        isLoading={isLoading}
        onSendMessage={handleSendMessage}
        onGoBack={handleBackToSelection}
      />
    );
  }

  return (
    <div className="min-h-screen bg-game-table-dark">
      <GameSelection
        search={{
          term: searchTerm,
          setTerm: setSearchTerm
        }}
        ui={{
          isLoading: false
        }}
        data={{
          games,
          onSelectGame: handleGameSelect
        }}
      />
    </div>
  );
}
